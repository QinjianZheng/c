				C Learning Note

1973 C language

C语言的特点：
	1. 基础性语言
	2.

需要阅读优秀的程序段
大量练习，面试题

1、数组和指针


hello.c:
编译器gcc：
源文件 - 预处理 - 编译 - 汇编 - 链接 -  可执行文件

需要了解：vim编辑器，常用脚本

	一、基本概念

1、以helloworld为例对写程序的思路提出如下要求：
	1）头文件包含的重要性
	2）以函数为单位来进行程序编写
	3）声明部分+实现部分
	4）return 0;
	5）多用空格和空行！
	6）适当添加注释(/* */, //...)

2、算法：解决问题的方法。（流程图，NS图，有限状态机FSM - Finite State Machine）
3、程序：用某种语言实现算法
4、进程：
	1）防止写越界，防止内存泄漏，谁打开谁关闭，谁申请谁释放

	二、数据结构，运算法和表达式

1、数据类型：（基本数据类型）
	1）基本类型
		- 数值类型：
			· 整形
				= 短整型short
				= 整型int
				= 长整型long
			· 浮点型
				= 单精度float
				= 双精度double
		- 字符类型 char
	2）构造类型
		- 数组
		- ...
		- 枚举 emu
	3）指针类型
	4）空类型 void

基本类型
	1）所占字节数：有类型之间的所占字节数范围区别，具体字节数取决于具体的机器（32位，64位等等）
	2）存储区别
		整型数是以补码形式存储
			-254 -> 254 -> 1111 1110 取反 +1
		浮点型数以0.314*10^1 -> 整数部分为0，精度和指数
			单精度 32位
				|31|30|..|23|22|...|0|
			符号1位  指数8位  浮点数23位
			双精度 64位
				剩下的位数都加在指数上，所以可以表示更大的数字
	3）不同类型的数据间类型转换
		example 
			254 -> unsigned int -> 32位（假设
			8421法：
				2进制转8进制，3个数字一组（111 -> 4+2+1 -> 7）
				2进制转16进制，4个数字一组 （1111 -> 8+4+2+1 -> F）
			(254)10 = (11111110)2 = (011 111 110)2 = (376)8 = (1111 1110)2 = (FE)16
			二进制 B111111110
			八进制 0376
			十六进制 0xFE
		隐性转换
			小容器不能装大内容，会失去精度		
			低精度和高精度进行运算，所得结果会是高精度类型
		显性转换 -> 强制类型转换
	4）特殊性：
		（1）布尔型bool
		（2）float类型，不是一个具体精确的值，只是一个有限精度的数，所以需要注意非常高精度的数运算
		（3）char型是否有符号，未定义的行为
		（4）不同形式的0值：0, '0', "0", '\0'
				需要进行区分
		（5）数据类型与后续代码中所使用的输入输出要相匹配

2、常量与变量
常量：在程序执行过程中值不会发生变化的量
	分类：
	1）整型常量
		1，790...
	2）实型常量
		3.14，5.26...
	3）字符常量：由单引号引起来的单个的字符或转义字符
		'a', '\n', '\t', '\015', '\x7f', ...
	4）字符串常量：由双引号的引起来的一个或多个字符组成的序列
		""（空串）, "string", "a", "abc\n\021\018"
	5）标识常量
		#define, 处理在程序的预处理阶段，占编译时间，一改全改
			缺点：不检查语法，只是单纯的宏体与宏名之间的替换

变量：用来保存一些特定内容，并且在程序执行过程中值随时发生会变化的量
	定义：[存储类型] 数据类型 标识符 = 值;
					 TYPE	  NAME   = VALUE;

		标识符：由字母、数字、下划线组成且不能以数字开头的一个标识序列
				内存分配空间的名字
			写标识符的要求：尽量做到见名生义
		数据类型：基本数据类型+构造类型
		值：注意匹配（数据类型）
		存储类型：auto static register extern(说明型）
			auto：默认（没有指定存储类型所使用的类型）自动分配和回收空间
			register：（建议型）寄存器类型（寄存器存在于CPU中）只能定义局部变量，不能定义全局变量；
				大小有限制，只能定义32位大小的数据类型（在32位的环境下），如double就不行；
				寄存器没有地址，所以一个寄存器类型的变量无法打印出地址查看或使用。
			static：静态型，自动初始化为0值或空值，并其变量的值有继承性。另外，常用于修饰变量或函数
			extern：说明型，意味着不能改变被说明的变量的值或类型

	变量的生命周期和作用范围：
		1）全局变量和局部变量
		2）局部变量和局部变量
		3）存储类型比较 -- 图片

3、运算符和表达式

表达式与语句的区别
	加分号叫语句，不加叫表达式
	i = 1;
	i  = j * 2;

运算符部分：
	1）每个运算符所需要的参与运算的操作数个数
	...
	3）条件判断（op1 ? op2 : op3) -- 如果op1的值为真则取op2的值，否则取op3的值
	4）逻辑运算符（&&,||）的短路特性（是否对表达式进行运算）
	5）位运算的重要意义
		（在当前嵌入式开发中尤为重要）
		(<<,  >>, ~, |, ^, &)
		<< 左移一位，最右边补零，相当于乘以2
		>> 右移一位，最左边补零，相等于除以2
		~ 取反 (0 -- 1, 1 -- 0)

		｜ 按位取或
		
			1 1 0 0
		｜  1 0 0 1
		-------------
			1 1 0 1
	
		& 按位取与 
 
	        1 1 0 0
        &   1 0 0 1
        -------------
            1 0 0 0

		^ 异或， 相同为0，不同为1

	        1 1 0 0
        ^   1 0 0 1
        -------------
            0 1 0 1


		需要掌握的算法：
			（1）将操作数中第n位置1，其他位不变； num = num | 1 << n; 
				-- 将1左移n位，对num和1（n个0）取按位或，因为第n位是1，所以所得结果的第n位一定是1，其他位不变
			（2）将操作数中第n位清0，其他位不变； num = num & ~(1 << n);
				-- 将1左移n位之后取反，结果为，对num和0（n个0）取按位与，因为第n位是0，所以所得结果的
			（3）测试第n位：if(num & 1 << n);
			（4）从一个指定宽度的数中取出其中的某几位？

			三、输入输出专题

input & output -> I/O（标准IO，文件IO）
1、格式化输入输出函数：
	scanf
		int scanf(const char *restrict format, ...);
			format: 抑制符*
			%s的使用是比较危险的，因为不知道存储空间大小
			scanf放在循环结构中要注意能否接收到正常有效的内容
	printf
		int printf(const char * restrict format, ...);
			format: "%[修饰符]格式字符", 参照图片标准输出修饰符与输入输出格式
					修饰符，宽度，保留小数位数，对齐等等		
2、字符输入输出函数：
	getchar
		int getchar(void);
	putchar
3、字符串输入输出函数：
	gets(!)
		char *gets(char *str);
			it is not safe to use gets(), use fgets() or getline() instead
			
		char *fgets(char * restrict str, int size, FILE * restrict stream);

		ssize_t	getline(char ** restrict linep, size_t * restrict linecapp, FILE * restrict stream);
	puts

输入、输出部分的练习

							流程控制

顺序，选择，循环
NS图，流程图，工具Dia
简单结构与复杂结构：自然结构

顺序：语句逐句执行
选择：出现了一种以上的情况
循环：在某个条件成立的情况下，重复执行某个动作

详解switch-case

有限状态机

语法格式：

	switch(exp)
	{
		case 常量或常量表达式:
			break;
		case 常量或常量表达式:
            break;		
		...
		
		default:
	}


if-goto:（慎用）
	goto实现的是无条件跳转，且不能跨函数跳转
	
					五、数组
							构造类型之一，连续存放


一维数组
	1 定义
		[存储类型] 数据类型 标识符 [下标]

	2 初始化
			用以逗号分隔的值列表来初始化数组
		不初始化
		全部初始化
		部分初始化
		static -- 自动初始化所有值为0
		
	3 元素引用
		数组名[下标]

	4 数组名
		当前数组的起始位置 arr -- arr[0] 地址相同 数组名是地址常量
	5 数组越界
		由于存在指针偏移，数组越界编译器不检查
			int	arr[3] = {1,2,3}
			printf(arr[3]); -- 这一行是的值为 arr[3] = *(arr + 3) 其实是找到了arr位置+3的地址所代表的值
练习：
1. 求fibonacci数列的前十项，并在数组中逆序存放
2. 数据排序：冒泡，选择法，快速排序
3. 进制转换
4. 删除法求质数


二维数组
	1 定义，初始化
		[存储类型] 数据类型 标识符 [行下标] [列下标]
	2 元素引用
		数组名[行标][列标]
	3 存储形式
		顺序存储，按行存储
	4 深入理解二维数组
		行指针
	a[0]->	a[0][0]
			a[0][1]
			a[0][2]
	a[1]->	a[1][0]	
            a[1][1]
            a[1][2]

练习：
1 行列互换（转置）
2 求最大值及其所在位置
3 求各行各列的和
4 矩阵乘积


字符数组
	1 定义，初始化，存储特点
		[存储类型] 数据类型 标识符 [下标]...
		初始化：
			单个字符初始化
			字符串常量初始化
			
	2 输入输出
	3 常用函数



